The Root Directory

The App Directory : 
contains the core code of your application. however, almost all of the classes in your application will be in this directory.

The Bootstrap Directory : 
contains the app.php file which bootstraps the framework. 
This directory also houses a cache directory which contains framework generated files for performance optimization such as the route and services cache files.

The Config Directory

The config directory, as the name implies, contains all of your application's configuration files. 
It's a great idea to read through all of these files and familiarize yourself with all of the options available to you.

The Database Directory

The database directory contains your database migrations, model factories, and seeds. 
If you wish, you may also use this directory to hold an SQLite database.

The Public Directory

The public directory contains the index.php file, which is the entry point for all requests entering your application and configures autoloading.
 This directory also houses your assets such as images, JavaScript, and CSS.

The Resources Directory

The resources directory contains your views as well as your raw, un-compiled assets such as LESS, SASS, or JavaScript. This directory also houses all of your language files.

The Routes Directory

The routes directory contains all of the route definitions for your application. By default, several route files are included with Laravel: web.php, api.php, console.php and channels.php.

The web.php file contains routes that the RouteServiceProvider places in the web middleware group, which provides session state, CSRF protection, and cookie encryption. 
If your application does not offer a stateless, RESTful API, all of your routes will most likely be defined in the web.php file.

The api.php file contains routes that the RouteServiceProvider places in the api middleware group, which provides rate limiting. 
These routes are intended to be stateless, so requests entering the application through these routes are intended to be authenticated via tokens and will not have access to session state.

The console.php file is where you may define all of your Closure based console commands. 
Each Closure is bound to a command instance allowing a simple approach to interacting with each command's IO methods. 
Even though this file does not define HTTP routes, it defines console based entry points (routes) into your application.

The channels.php file is where you may register all of the event broadcasting channels that your application supports.

The Storage Directory

The storage directory contains your compiled Blade templates, file based sessions, file caches, and other files generated by the framework. 
This directory is segregated into app, framework, and logs directories. The app directory may be used to store any files generated by your application. 
The framework directory is used to store framework generated files and caches. Finally, the logs directory contains your application's log files.

The storage/app/public directory may be used to store user-generated files, such as profile avatars, that should be publicly accessible. You should create a symbolic link at public/storage which points to this directory. You may create the link using the php artisan storage:link command.

The Tests Directory

The tests directory contains your automated tests. An example PHPUnit test is provided out of the box. Each test class should be suffixed with the word Test. You may run your tests using the phpunit or php vendor/bin/phpunit commands.

The Vendor Directory

The vendor directory contains your Composer dependencies.


-------------------The App Directory----------------------

The majority of your application is housed in the app directory. By default, this directory is namespaced under App and is autoloaded by Composer using the PSR-4 autoloading standard.

The Console Directory

The Console directory contains all of the custom Artisan commands for your application. These commands may be generated using the make:command command. 
This directory also houses your console kernel, which is where your custom Artisan commands are registered and your scheduled tasks are defined.


The Exceptions Directory

The Exceptions directory contains your application's exception handler and is also a good place to place any exceptions thrown by your application. If you would like to customize how your exceptions are logged or rendered, you should modify the Handler class in this directory.

The Http Directory

The Http directory contains your controllers, middleware, and form requests. Almost all of the logic to handle requests entering your application will be placed in this directory.


The Providers Directory

The Providers directory contains all of the service providers for your application. Service providers bootstrap your application by binding services in the service container, registering events, or performing any other tasks to prepare your application for incoming requests.

In a fresh Laravel application, this directory will already contain several providers. You are free to add your own providers to this directory as needed.

--------------------------How to send data using redirect with Laravel--------------------------------



In store()

return Redirect::route('clients.show, $id')->with( ['data' => $data] );

and in show() read it with

Session::get('data');

-----------------------AJAX Requests & Validation-----------------------------------

In this example, we used a traditional form to send data to the application. However, many applications use AJAX requests. 
When using the validate method during an AJAX request, Laravel will not generate a redirect response. 
Instead, Laravel generates a JSON response containing all of the validation errors. This JSON response will be sent with a 422 HTTP status code.

--------How to print arrays inside Laravel blade?---------------
{{dd($var)}}
OR
@php(dd($var))
OR
@php dd($var); @endphp

-----------------------------Manually creating validators----------------------------------
in controller's store method
 $validator = Validator::make($request->all(), [
            'title' => 'required|unique:posts|max:255',
            'body' => 'required',
        ]);

        if ($validator->fails()) {
            return redirect('post/create')
                        ->withErrors($validator)
                        ->withInput();
        }

//inbuilt validations 

        $request->validate([
            'name' =>'required|string',
            'email' =>'required|unique:users|email|string',
            'password'=>'required|min:5|confirmed'
        ]);
// manually added validations using facade		
        $validator = Validator::make($request->all(), [
                    'name' => 'required|string',
                    'email' => 'required|unique:users|email|string',
                    'password' => 'required|min:5|confirmed'
        ]);

// manually added validations using facade with customised messages
        $messages = [
            'email.required' => 'We need to know your e-mail address!',
            'email.unique' => 'Email is already taken!',
        ];

        $rules = [
            'name' => 'required|string',
            'email' => 'required|unique:users|email|string',
            'password' => 'required|min:5|confirmed', //confirm password column name should be password_confirmation
            'mobile_number' => 'required'
        ];
				
        $validator = Validator::make($request->all(), $rules, $messages);

        if ($validator->fails()) {
            return redirect('user/create')
                            ->withErrors($validator)
                            ->withInput();
        }
		
The first argument passed to the make method is the data under validation. The second argument is the validation rules that should be applied to the data.

After checking if the request validation failed, you may use the withErrors method to flash the error messages to the session. 
When using this method, the $errors variable will automatically be shared with your views after redirection, allowing you to easily display them back to the user. 
The withErrors method accepts a validator, a MessageBag, or a PHP array

----------Automatic Redirection
Validator::make($request->all(), [
    'title' => 'required|unique:posts|max:255',
    'body' => 'required',
])->validate();


---------Named Error Bags

If you have multiple forms on a single page, you may wish to name the MessageBag of errors, allowing you to retrieve the error messages for a specific form. Pass a name as the second argument to withErrors:

return redirect('register')->withErrors($validator, 'login');

You may then access the named MessageBag instance from the $errors variable:

{{ $errors->login->first('email') }}


-----------What is the difference between find(), findOrFail(), first(), firstOrFail(), get(), list(), toArray()----------------


    find($id) takes an id and returns a single model. If no matching model exist, it returns null.

    findOrFail($id) takes an id and returns a single model. If no matching model exist, it throws an error1.

    first() returns the first record found in the database. If no matching model exist, it returns null.

    firstOrFail() returns the first record found in the database. If no matching model exist, it throws an error1.

    get() returns a collection of models matching the query.

    pluck($column) returns a collection of just the values in the given column. In previous versions of Laravel this method was called lists.

    toArray() converts the model/collection into a simple PHP array.
	
	------------------Sharing Data With All Views-----------------------
You should place calls to share within a service provider's boot method. You are free to add them to the AppServiceProvider or generate a separate service provider to house them:

public function boot()
    {
        View::share('key', 'value');
    }
	
	-----------------How to access URL segment(s) in blade in Laravel 5?----------------------
Request::segments()

















